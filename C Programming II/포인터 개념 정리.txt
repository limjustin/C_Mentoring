<포인터 변수의 크기는 항상 일정하다!> (1번)
int double char : 일반 자료형은 "값"을 담음
 7    3.14    'c' 
값 크기에 따라서 달리 담는 이유가 머였냐면
여기에 있는 자료형은, "값"의 크기에 따라 달라져요!!

int* double* char* : "주소"를 담음 (포인터는 주소)
얘는 그냥 "주소"를 담는거잖아!!
주소의 크기는 항상 일정해 -> 포인터 변수의 크기도 일정
64비트 환경 : 8바이트
32비트 환경 : 4바이트
--------------------------------------------------------------------------
<배열의 이름은 배열의 가장 첫번째 원소를 가리킨다!> (2 ,3번)
배열의 이름을 %p(주소)로 출력하면
배열의 첫번째 원소(0번째 인덱스)의 주소값과 똑같이 나온다는거야!!

배열의 이름 -> 배열 가장 첫번째 원소(0번째)를 가리킨다!!
arr == &arr[0]
배열도 포인터랑 비슷한 친구라고 생각하면 됑
배열의 이름은 무조건 배열의 첫번째 원소를 가리킨다!!

배열의 이름은 배열의 가장 첫번째 원소를 가리킨다
*arr1 = *(&arr1[0])
--------------------------------------------------------------------------
<포인터 연산에 관련> (4번)
그 자료형만큼 뛴다라고 생각하면 돼!!

ptr + 1
&arr[0] + 4
포인터에 더하기 연산을 진행하면
주소 값에 +1이 아니라,
자료형만큼 뛴다라고 생각하면 됌

배열은 포인터랑 비슷한 녀석 (= 배열의 이름도 포인터)
그래서, 배열도 포인터처럼 표기 가능!!

arr[i] == *(arr + i)
i번째 원소
배열 포인터가 가리키는 i번째 원소의 주소의 값
--------------------------------------------------------------------------
<Summary>
1. 배열도 포인터처럼 사용할 수 있다!!
2. 배열의 이름은 배열의 첫번째 주소를 가리킨다
3. 포인터 변수의 크기는 8byte로 일정(64bit)
4. 배열의 첫 번째 요소에 포인터를 가리키고 포인터를 하나 증가시키면,
   (자료형만큼 증가되기 때문에) 배열의 그 다음 요소를 가리킨다.
--------------------------------------------------------------------------